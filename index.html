<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>MCQ + Fill-in (GitHub Pages • Multi-part, Superscripts, Degrees)</title>
<style>
  body { font-family: Arial, sans-serif; font-size:16px; line-height:1.4; margin:0; padding:16px; }
  h1 { font-size:20px; margin:0 0 10px; }
  .status { font-size:14px; color:#555; margin-bottom:10px; }

  .loader { border:1px dashed #bbb; border-radius:8px; padding:12px; margin:12px 0; }
  .loader strong { display:block; margin-bottom:8px; }
  .loader .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  .loader input[type="text"] { flex:1 1 320px; font-size:16px; padding:8px 10px; }
  .loader button { font-size:16px; padding:8px 12px; }

  .hud { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin:12px 0; }
  .hud .pill { background:#f5f5f5; border:1px solid #ddd; border-radius:999px; padding:6px 10px; }
  .spacer { flex:1 1 auto; }

  .stage { border:1px solid #ddd; border-radius:8px; padding:12px; margin:12px 0; min-height:160px; transition: background-color 0.3s; }
  .q-title { font-weight:bold; margin-bottom:8px; }
  .q-img { display:block; max-width:100%; height:auto; margin:6px 0 10px; }
  .options label { margin-right:12px; display:inline-block; padding:4px 0; cursor:pointer; }

  .fitb-wrap { margin-top:8px; }
  .fitb-input { width:100%; max-width:360px; font-size:18px; padding:10px 12px; border:2px solid #888; border-radius:6px; }
  .fitb-input:focus { outline:none; border-color:#555; }
  .fitb-hint { font-size:13px; color:#666; margin-top:6px; }

  .answer-key { font-size:14px; color:#333; margin-top:10px; display:inline-block; }
  .hidden { display:none; }

  /* Bright, high-contrast feedback for whole-card */
  .correct { background:#00c851; color:white; border-color:#009c3a; }
  .wrong   { background:#ff4444; color:white; border-color:#cc0000; }
  .correct-choice { font-weight:bold; text-decoration: underline; }

  /* Per-part feedback */
  .parts { margin-top:8px; display:flex; flex-direction:column; gap:10px; }
  .part-row { display:flex; align-items:flex-start; gap:10px; flex-wrap:wrap; }
  .part-label { min-width:34px; font-weight:bold; }
  .part-input { width:100%; max-width:360px; font-size:18px; padding:10px 12px; border:2px solid #888; border-radius:6px; }
  .part-input.correct { border-color:#0a0; background:#eaffea; }
  .part-input.wrong   { border-color:#c00; background:#ffeaea; }
  .part-key { font-size:13px; color:#444; margin-left:4px; }

  .nav { display:flex; gap:8px; flex-wrap:wrap; margin:10px 0 0; }
  .nav button, .nav select { font-size:16px; padding:8px 12px; }
  .controls { display:flex; gap:10px; flex-wrap:wrap; margin:14px 0; }
  .result { margin-top:8px; font-weight:bold; }

  .muted { color:#777; font-size:13px; }
</style>
</head>
<body>

<h1>MCQ + Fill-in (GitHub Pages • One-at-a-time)</h1>
<div id="status" class="status">Auto-loading <code>mcq.txt</code> from the same folder…</div>

<div class="loader">
  <strong>1) Source for mcq.txt</strong>
  <div class="row">
    <input id="mcqUrl" type="text" placeholder="mcq.txt URL or relative path" value="mcq.txt">
    <button id="btnLoad" type="button">Load</button>
    <button id="btnReload" type="button" title="Re-fetch the current URL">Reload</button>
  </div>
  <div class="muted">Tip: You can also set <code>?file=path/mcq.txt</code> in the URL.</div>
</div>

<div id="quizArea" class="hidden">
  <div class="hud">
    <span id="progress" class="pill">Q 0 / 0</span>
    <span id="liveScore" class="pill">Score so far: 0 / 0</span>
    <span class="spacer"></span>
    <label class="pill">Jump:
      <select id="jumpSelect"></select>
    </label>
    <button id="btnFirstUnanswered" class="pill" type="button">First Unanswered</button>
  </div>

  <div id="stage" class="stage"></div>

  <div class="nav">
    <button id="btnPrev"  type="button">◀ Prev</button>
    <button id="btnNext"  type="button">Next ▶</button>
  </div>

  <div class="controls">
    <button id="btnSubmit" type="button">Submit</button>
    <button id="btnReset"  type="button">Reset</button>
  </div>
  <div id="score" class="result"></div>
</div>

<script>
/* -------- GitHub Pages version (fetch-based) with FITB (single + multi-part) --------
   - Auto fetches mcq.txt from same folder (or ?file=...).
   - MCQ when answer is 1..4
   - Single FITB: acceptable variants inside \...\ or /.../
   - Multi-part FITB: separate parts by "|" and optional labels like a:\...\ b:\...\
   - Strict display format: prefix a variant with "=" (e.g., \=1.6\) to require exact text.
   - Superscript UX: "cm2" / "cm^2" -> "cm²" while typing; grading treats them the same.
   - Degree UX: "50^o" / "50 deg" -> "50°" while typing; grading treats them the same.
   - Inputs auto-grow maxlength based on key + typed content.
   - NEW: If the student's answer is correct, do NOT reveal the key.
*/

let items = []; // See parseMCQ for shape per type
let userAnswers = []; // mcq:number|null; fitb:string|null; fitb-multi:string[] (per part) or nulls
let revealed = [];    // mcq:boolean; fitb:boolean; fitb-multi:boolean[] (per part)
let current = 0;
let currentMCQUrl = "mcq.txt"; // default

function $(id){ return document.getElementById(id); }
function normalizeLineEndings(s){return s.replace(/\r\n/g,"\n").replace(/\r/g,"\n");}

function splitRow(line){
  if(line.indexOf("\t")!==-1){var p=line.split("\t");return [p[0],p[1]];}
  const p2=line.trim().split(/\s{2,}/); if(p2.length>=2) return [p2[0],p2[1]];
  const t=line.trim().split(/\s+/); if(t.length>=2){const ans=t.pop(); return [t.join(" "), ans];}
  return [line.trim(),""];
}

function isHttpUrl(s){ return /^https?:\/\//i.test(s); }
function looksLikeImage(s){ return /\.(jpg|jpeg|png|gif|bmp|webp)$/i.test(s) || isHttpUrl(s); }
function getImgSrc(q){ return q; } // filenames resolve relative to this HTML on GitHub Pages

/* ---------------- Variant extraction: supports \...\ (preferred) and /.../ (legacy) --------------- */
function parseAlts(aRaw){
  const out = [];
  if (!aRaw) return out;

  // Backslash blocks: \ ... \
  let m;
  const reBack = /\\([^\\]*)\\/g;
  while ((m = reBack.exec(aRaw)) !== null) {
    const s = (m[1] || "").trim();
    if (s) out.push(s);
  }

  // Forward-slash blocks: / ... /
  const reFwd = /\/([^\/]*)\//g;
  while ((m = reFwd.exec(aRaw)) !== null) {
    const s = (m[1] || "").trim();
    if (s) out.push(s);
  }

  return out;
}

/* ---------------- Multi-part field parser (a:\...\ | b:\...\) ---------------- */
function parsePartsField(field){
  const rawParts = field.split(/\s*\|\s*/).filter(Boolean);
  if(!rawParts.length) return null;
  const parts = [];
  let nextAuto = 0;
  const alpha = "abcdefghijklmnopqrstuvwxyz";

  for(let seg of rawParts){
    let label = null;
    let body = seg.trim();

    const m = body.match(/^\s*([A-Za-z]+)\s*:\s*(.*)$/);
    if(m){
      label = m[1].toLowerCase();
      body  = m[2];
    }else{
      label = alpha[nextAuto] || String(nextAuto+1);
      nextAuto++;
    }

    const alts = parseAlts(body);
    parts.push({ label, answersText: alts });
  }
  return parts;
}

/* ---------------- Parse whole mcq.txt ---------------- */
function parseMCQ(text){
  const out=[], lines=normalizeLineEndings(text).split("\n");
  for(let raw of lines){
    if(!raw) continue;
    const line = raw.trim(); if(!line || line.startsWith("#")) continue; // allow comments
    const parts = splitRow(line);
    const q = (parts[0]||"").trim();
    const aRaw = (parts[1]||"").trim();
    if(!q) continue;

    // Multi-part FITB: detect "|" in the answer field
    if(aRaw.includes("|")){
      const mp = parsePartsField(aRaw);
      if(mp && mp.length){
        out.push({ type:'fitb-multi', question:q, parts: mp });
        continue;
      }
    }

    // Single FITB: any alt segments
    const alts = parseAlts(aRaw);
    if(alts.length){
      out.push({ type:'fitb', question:q, answer:null, answersText: alts });
      continue;
    }

    // MCQ numeric 1..4
    const ans = parseInt(aRaw,10);
    if(!isNaN(ans) && ans>=1 && ans<=4){
      out.push({ type:'mcq', question:q, answer:ans, answersText:null });
    }else{
      out.push({ type:'mcq', question:q, answer:null, answersText:null }); // unscorable / missing key
    }
  }
  return out;
}

/* ---------------- State ---------------- */
function initState(n){
  userAnswers = new Array(n);
  revealed    = new Array(n);
  for(let i=0;i<n;i++){
    const it = items[i];
    if(it.type==='mcq'){ userAnswers[i]=null; revealed[i]=false; }
    else if(it.type==='fitb'){ userAnswers[i]=null; revealed[i]=false; }
    else if(it.type==='fitb-multi'){
      userAnswers[i] = it.parts.map(()=>null);
      revealed[i]    = it.parts.map(()=>false);
    }
  }
  current = 0;
}

/* ---------------- Superscript & degree helpers (UX + grading) ---------------- */
const SUP_DIGITS = { "0":"⁰","1":"¹","2":"²","3":"³","4":"⁴","5":"⁵","6":"⁶","7":"⁷","8":"⁸","9":"⁹" };
const DESUP = { "⁰":"0","¹":"1","²":"2","³":"3","⁴":"4","⁵":"5","⁶":"6","⁷":"7","⁸":"8","⁹":"9" };

function desuperscriptDigits(s){
  return String(s).replace(/[⁰¹²³⁴⁵⁶⁷⁸⁹]/g, ch => DESUP[ch] || ch);
}

// Turn "^2" → "²", "^3" → "³"; "cm2"/"m3" → "cm²"/"m³"; degrees: "50^o"/"50 deg" → "50°"
// (Intentionally NOT supporting bare "50o")
function prettifyExponentsForDisplay(s){
  let t = String(s);

  // caret style exponents
  t = t.replace(/\^([0-9])/g, (_,d) => SUP_DIGITS[d] || "^"+d);

  // common unit patterns (customize if you like)
  const unitRe = /\b(km|m|cm|mm|dm|ml|mL|l|L)\s*([23])\b/g;
  t = t.replace(unitRe, (_,u,d) => u + (d==="2"?"²":"³"));

  // generic: letters + 2/3 at end, e.g., "cm2" "m3"
  t = t.replace(/\b([a-zA-Z]+)\s*([23])\b/g, (_,letters,d) =>
    letters + (d==="2" ? "²" : "³")
  );

  // degrees: 50^o -> 50°, 50 deg -> 50°
  t = t.replace(/(\d+)\s*\^\s*[oO]\b/g, (_, n) => n + "°");
  t = t.replace(/(\d+)\s*(?:deg|degrees?)\b/gi, (_, n) => n + "°");

  return t;
}

function prettifyExponentsInPlace(inputEl){
  const prev = inputEl.value;
  const next = prettifyExponentsForDisplay(prev);
  if (next !== prev) {
    const selEnd = inputEl.selectionEnd;
    inputEl.value = next;
    if (typeof selEnd === "number") inputEl.selectionEnd = inputEl.selectionStart = selEnd;
  }
}

/* ---------------- Dynamic maxlength helpers ---------------- */
function displayLength(s){
  return prettifyExponentsForDisplay(String(s || "")).length;
}
function computeDesiredMaxLength(answersText, currentVal){
  const BASE_MIN = 10, CAP_MAX = 64, BUF = 2;
  let longestKey = 0;
  if (Array.isArray(answersText) && answersText.length){
    for (const a of answersText){
      longestKey = Math.max(longestKey, displayLength(a));
    }
  }
  const typedLen = displayLength(currentVal || "");
  const want = Math.max(BASE_MIN, longestKey + BUF, typedLen + BUF);
  return Math.min(want, CAP_MAX);
}
function adjustMaxLengthForInput(inputEl, answersText){
  if (!inputEl) return;
  const desired = computeDesiredMaxLength(answersText, inputEl.value);
  const current = Number(inputEl.getAttribute("maxlength") || "0");
  if (!current || desired !== current){
    inputEl.setAttribute("maxlength", String(desired));
  }
}

/* ---------------- Canonicalization & matching ---------------- */

// Normalize to ASCII lower-case
function toAsciiLower(s) {
  return String(s || "")
    .normalize("NFKC")
    .toLowerCase();
}

// Map common unit spellings to canonical short forms
const UNIT_RULES = [
  [/\b(litre|liter|liters|litres|l)\b/g, "l"],
  [/\b(millilitre|milliliter|milliliters|millilitres|ml)\b/g, "ml"],
  [/\b(centimetre|centimeter|centimetres|centimeters|cm)\b/g, "cm"],
  [/\b(metre|meter|metres|meters|m)\b/g, "m"],
  [/\b(gram|grams|g)\b/g, "g"],
  [/\b(kilogram|kilograms|kg)\b/g, "kg"],
  [/\b(hour|hours|hr|hrs|h)\b/g, "h"],
  [/\b(minute|minutes|min|mins)\b/g, "min"],
  [/\b(second|seconds|sec|secs|s)\b/g, "s"],
  [/\b(degree|degrees|deg)\b/g, "deg"],   // degrees normalized
];

// Preprocess but keep spaces (for mixed numbers like "1 3/5")
// Also: normalize superscripts → digits; degree symbol → "deg"
function preprocessText(s) {
  let t = toAsciiLower(s)
    .replace(/[.,]/g, "")   // drop dots/commas
    .replace(/ℓ/g, "l");    // fancy liter symbol

  t = desuperscriptDigits(t);

  // degree symbol → "deg"
  t = t.replace(/°/g, " deg ");

  // normalize spacing around slashes: "1 3 / 5" -> "1 3/5"
  t = t.replace(/\s*\/\s*/g, "/");

  // apply unit canonicalization
  for (const [re, canon] of UNIT_RULES) t = t.replace(re, canon);

  return t.trim();
}

// Remove all spaces for cheap exact compare
function canonicalNoSpace(t) {
  return t.replace(/\s+/g, "");
}

// Parse numberish with optional unit from preprocessed string
function splitNumUnitLoose(prep) {
  // mixed: a b/c
  let m = prep.match(/^(\d+)\s+(\d+)\/(\d+)\s*([a-zµ]*)$/i);
  if (m) {
    const a = parseInt(m[1],10), b = parseInt(m[2],10), c = parseInt(m[3],10);
    const unit = (m[4] || "").toLowerCase();
    if (c !== 0) return { num: a + b/c, unit };
  }

  // fraction: b/c
  m = prep.match(/^(\d+)\/(\d+)\s*([a-zµ]*)$/i);
  if (m) {
    const b = parseInt(m[1],10), c = parseInt(m[2],10);
    const unit = (m[3] || "").toLowerCase();
    if (c !== 0) return { num: b/c, unit };
  }

  // decimal/int
  m = prep.match(/^(\d+(?:\.\d+)?)\s*([a-zµ]*)$/i);
  if (m) {
    const num = Number(m[1]);
    const unit = (m[2] || "").toLowerCase();
    if (Number.isFinite(num)) return { num, unit };
  }

  return null; // not a simple quantity
}

// Strict-or-fuzzy comparison
function answersEquivalent(user, key) {
  if (typeof user !== "string" || typeof key !== "string") return false;

  // STRICT MODE: "=text" -> exact match (trim only)
  if (key.startsWith("=")) {
    const must = key.slice(1);
    return user.trim() === must.trim();
  }

  // FUZZY MODE:
  const uPrep = preprocessText(user);
  const kPrep = preprocessText(key);

  // cheap canonical match (spaces-insensitive, units normalized)
  if (canonicalNoSpace(uPrep) === canonicalNoSpace(kPrep)) return true;

  // numeric+unit compare
  const uu = splitNumUnitLoose(uPrep);
  const kk = splitNumUnitLoose(kPrep);
  if (uu && kk) {
    if (uu.unit !== kk.unit) return false;         // unit must match ("" allowed)
    if (uu.num == null || kk.num == null) return false;
    return Math.abs(uu.num - kk.num) < 1e-9;       // tolerance can be relaxed if needed
  }

  return false;
}

function isFitbCorrect(user, answers) {
  if (typeof user !== "string" || !answers || !answers.length) return false;
  for (const a of answers) {
    if (answersEquivalent(user, a)) return true;
  }
  return false;
}

/* ---------------- Scoring, UI helpers ---------------- */
function tallyScore(){
  let correct=0, total=0;
  for(let i=0;i<items.length;i++){
    const it = items[i];
    if(it.type==='mcq' && it.answer!=null){
      total++;
      if(userAnswers[i]===it.answer) correct++;
    }else if(it.type==='fitb' && it.answersText && it.answersText.length){
      total++;
      if(isFitbCorrect(userAnswers[i], it.answersText)) correct++;
    }else if(it.type==='fitb-multi'){
      for(let k=0;k<it.parts.length;k++){
        const p = it.parts[k];
        if(p.answersText && p.answersText.length){
          total++;
          const ua = (userAnswers[i]||[])[k];
          if(isFitbCorrect(ua, p.answersText)) correct++;
        }
      }
    }
  }
  return {correct,total};
}

function previewStem(q){
  if(looksLikeImage(q)) return "[image]";
  const s = q.trim();
  return s.length>24 ? s.slice(0,24)+"…" : s || "(blank)";
}

function itemStatus(i){
  const it = items[i];
  if(it.type==='mcq'){
    if(items[i].answer==null) return (userAnswers[i]==null ? " " : "✗ ");
    if(userAnswers[i]==null) return " ";
    return (userAnswers[i]===it.answer) ? "✓ " : "✗ ";
  }else if(it.type==='fitb'){
    if(!it.answersText || !it.answersText.length) return (userAnswers[i]==null ? " " : "✗ ");
    if(userAnswers[i]==null) return " ";
    return isFitbCorrect(userAnswers[i], it.answersText) ? "✓ " : "✗ ";
  }else{
    let scorable=0, correct=0, touched=false;
    for(let k=0;k<it.parts.length;k++){
      const p=it.parts[k];
      if(p.answersText && p.answersText.length){
        scorable++;
        const ua = (userAnswers[i]||[])[k];
        if(ua!=null && ua!=="") touched = true;
        if(isFitbCorrect(ua, p.answersText)) correct++;
      }
    }
    if(scorable===0) return touched ? "✗ " : " ";
    if(correct===scorable) return "✓ ";
    return touched ? "✗ " : " ";
  }
}

function updateHUD(){
  $("progress").textContent = `Q ${items.length? current+1:0} / ${items.length}`;
  const tally = tallyScore();
  $("liveScore").textContent = `Score so far: ${tally.correct} / ${tally.total}`;

  const sel = $("jumpSelect");
  sel.innerHTML = "";
  for(let i=0;i<items.length;i++){
    const opt = document.createElement("option");
    opt.value = String(i);
    opt.textContent = `${i+1}. ${itemStatus(i)}${previewStem(items[i].question)}`;
    sel.appendChild(opt);
  }
  sel.value = String(current);

  $("btnPrev").disabled = (current<=0);
  $("btnNext").disabled = (current>=items.length-1);
}

/* ---------------- Rendering ---------------- */
function renderCurrent(){
  const stage = $("stage");
  stage.className = "stage";
  stage.innerHTML = "";

  if(!items.length){ stage.textContent = "No questions loaded."; return; }

  const it = items[current];

  // Stem
  if(looksLikeImage(it.question)){
    const img = document.createElement("img");
    img.className = "q-img";
    img.alt = `Question ${current+1}`;
    img.src = getImgSrc(it.question);
    stage.appendChild(img);
  }else{
    const p = document.createElement("div");
    p.className = "q-title";
    p.textContent = it.question || `(Question ${current+1})`;
    stage.appendChild(p);
  }

  if(it.type === 'mcq'){
    const opts=document.createElement("div");
    opts.className="options";
    for(let v=1; v<=4; v++){
      const id=`q${current}_${v}`;
      const label=document.createElement("label");
      label.setAttribute("data-val", String(v));
      const rb=document.createElement("input");
      rb.type="radio"; rb.name=`q${current}`; rb.id=id; rb.value=String(v);
      if(userAnswers[current]===v) rb.checked=true;
      label.htmlFor=id;
      label.appendChild(rb);
      label.appendChild(document.createTextNode(" "+v));
      opts.appendChild(label);
    }
    stage.appendChild(opts);

    // Key (show only when revealed AND answer is wrong/unknown)
    const chosen = userAnswers[current];
    const isCorrect = (it.answer!=null && chosen===it.answer);
    const key=document.createElement("span");
    key.id="key_current";
    key.className="answer-key"+((revealed[current] && !isCorrect)?"":" hidden");
    key.textContent = it.answer==null ? " (Answer: ?)" : ` (Answer: ${it.answer})`;
    stage.appendChild(key);

    if(chosen!=null && it.answer!=null){
      if(isCorrect){ stage.classList.add("correct"); }
      else{
        stage.classList.add("wrong");
        const cl=stage.querySelector(`.options label[data-val="${it.answer}"]`);
        if(cl) cl.classList.add("correct-choice");
      }
    }

    opts.addEventListener("change", function(ev){
      if(ev.target && ev.target.matches('input[type="radio"]')){
        onAnswerMCQ(parseInt(ev.target.value,10));
      }
    });

  }else if(it.type === 'fitb'){
    const wrap = document.createElement("div");
    wrap.className = "fitb-wrap";
    const inp = document.createElement("input");
    inp.id = "fitb_current";
    inp.className = "fitb-input";
    inp.type = "text";
    inp.placeholder = "Type your answer…";
    if(typeof userAnswers[current]==='string') inp.value = userAnswers[current];

    // Initial maxlength + prettify
    adjustMaxLengthForInput(inp, it.answersText);
    inp.addEventListener("input", () => {
      prettifyExponentsInPlace(inp);
      adjustMaxLengthForInput(inp, it.answersText);
    });

    wrap.appendChild(inp);

    const hint = document.createElement("div");
    hint.className = "fitb-hint";
    hint.textContent = "Press Enter or click outside to check.";
    wrap.appendChild(hint);

    stage.appendChild(wrap);

    const answered = typeof userAnswers[current]==='string';
    const okNow = answered && it.answersText && it.answersText.length
      ? isFitbCorrect(userAnswers[current], it.answersText) : false;

    const key=document.createElement("span");
    key.id="key_current";
    // Show key only if revealed AND (not correct)
    key.className="answer-key"+((revealed[current] && !okNow)?"":" hidden");
    const firstAns = (it.answersText && it.answersText.length) ? it.answersText[0] : null;
    key.textContent = firstAns ? ` (Answer: ${firstAns})` : " (Answer: ?)";
    stage.appendChild(key);

    if(answered && it.answersText && it.answersText.length){
      stage.classList.add(okNow ? "correct" : "wrong");
    }

    inp.addEventListener("keydown", (e)=>{
      if(e.key === "Enter"){
        e.preventDefault();
        onAnswerFITB(inp.value);
      }
    });
    inp.addEventListener("blur", ()=> onAnswerFITB(inp.value));

  }else{
    // Multi-part FITB
    const partsBox = document.createElement("div");
    partsBox.className = "parts";

    const ua = userAnswers[current] || [];
    const rv = revealed[current] || [];

    it.parts.forEach((p, idx)=>{
      const row = document.createElement("div");
      row.className = "part-row";

      const lab = document.createElement("div");
      lab.className = "part-label";
      lab.textContent = `(${(p.label||String.fromCharCode(97+idx)).toLowerCase()})`;
      row.appendChild(lab);

      const inp = document.createElement("input");
      inp.className = "part-input";
      inp.type = "text";
      inp.placeholder = "Answer…";
      if(typeof ua[idx]==='string') inp.value = ua[idx];

      // Initial maxlength + prettify + dynamic grow
      adjustMaxLengthForInput(inp, p.answersText);
      inp.addEventListener("input", () => {
        prettifyExponentsInPlace(inp);
        adjustMaxLengthForInput(inp, p.answersText);
      });

      const answered = typeof ua[idx]==='string' && ua[idx] !== "";
      const ok = answered && p.answersText && p.answersText.length
        ? isFitbCorrect(ua[idx], p.answersText) : false;

      const key = document.createElement("span");
      key.className = "part-key" + ((rv[idx] && !ok) ? "" : " hidden"); // reveal only if wrong
      const first = (p.answersText && p.answersText.length) ? p.answersText[0] : null;
      key.textContent = first ? `Answer: ${first}` : "Answer: ?";

      if(answered && p.answersText && p.answersText.length){
        inp.classList.toggle("correct", ok);
        inp.classList.toggle("wrong", !ok);
      }

      inp.addEventListener("keydown", (e)=>{
        if(e.key === "Enter"){
          e.preventDefault();
          onAnswerFITBMulti(idx, inp.value, inp, key, p.answersText);
        }
      });
      inp.addEventListener("blur", ()=>{
        onAnswerFITBMulti(idx, inp.value, inp, key, p.answersText);
      });

      row.appendChild(inp);
      row.appendChild(key);
      partsBox.appendChild(row);
    });

    const hint = document.createElement("div");
    hint.className = "fitb-hint";
    hint.textContent = "Each part is checked separately. Press Enter in a box to check that part.";
    partsBox.appendChild(hint);

    stage.appendChild(partsBox);
  }

  updateHUD();

  if(it.type==='mcq'){
    const first = stage.querySelector('input[type="radio"]');
    if(first && userAnswers[current]==null) first.focus();
  }else if(it.type==='fitb'){
    const input = $("fitb_current");
    if(input && userAnswers[current]==null) input.focus();
  }else{
    const first = stage.querySelector('.part-input');
    if(first){ first.focus(); }
  }
}

/* ---------------- Answer handlers ---------------- */
function onAnswerMCQ(chosen){
  const stage = $("stage");
  const key   = $("key_current");
  const it    = items[current];

  stage.classList.remove("correct","wrong");
  const prevHL = stage.querySelector(".correct-choice");
  if(prevHL) prevHL.classList.remove("correct-choice");

  userAnswers[current] = chosen;

  if(it.answer==null){
    if(key) key.classList.remove("hidden");
    revealed[current] = true;
    updateHUD();
    return;
  }

  const isCorrect = (chosen === it.answer);
  if(isCorrect){
    stage.classList.add("correct");
    // do NOT reveal key if correct
    if(key) key.classList.add("hidden");
  }else{
    stage.classList.add("wrong");
    const cl=stage.querySelector(`.options label[data-val="${it.answer}"]`);
    if(cl) cl.classList.add("correct-choice");
    if(key) key.classList.remove("hidden"); // reveal only on wrong
  }
  revealed[current] = true;
  updateHUD();
}

function onAnswerFITB(text){
  const stage = $("stage");
  const key   = $("key_current");
  const it    = items[current];

  stage.classList.remove("correct","wrong");
  userAnswers[current] = text;

  const ok = isFitbCorrect(text, it.answersText||[]);
  stage.classList.add(ok ? "correct" : "wrong");

  // Reveal key only if wrong or blank
  if(key && !ok) key.classList.remove("hidden");
  if(key && ok)  key.classList.add("hidden");

  revealed[current] = true;
  updateHUD();
}

function onAnswerFITBMulti(idx, value, inputEl, keyEl, answersText){
  const ua = userAnswers[current];
  const rv = revealed[current];
  if(Array.isArray(ua)){ ua[idx] = value; }
  if(Array.isArray(rv)){ rv[idx] = true; }

  const ok = isFitbCorrect(value, answersText||[]);
  inputEl.classList.toggle("correct", ok);
  inputEl.classList.toggle("wrong", !ok);

  // Reveal only if wrong or empty
  if(keyEl && !ok) keyEl.classList.remove("hidden");
  if(keyEl && ok)  keyEl.classList.add("hidden");

  updateHUD();
}

/* ---------------- Nav & scoring controls ---------------- */
function goPrev(){ if(current>0){ current--; renderCurrent(); } }
function goNext(){ if(current<items.length-1){ current++; renderCurrent(); } }

function finalizeScore(){
  const t = tallyScore();
  if(t.total>0) $("score").textContent = `Final score: ${t.correct} / ${t.total}`;
  else $("score").textContent = "No scorable questions (answers missing).";
  $("liveScore").textContent = `Score so far: ${t.correct} / ${t.total}`;
}

function submitQuiz(){
  for(let i=0;i<items.length;i++){
    if(items[i].type==='fitb-multi' && Array.isArray(revealed[i])){
      revealed[i] = revealed[i].map(()=>true);
    }else{
      revealed[i] = true;
    }
  }
  $("score").textContent = "";
  finalizeScore();
  renderCurrent(); // This will still show keys on submit (even for correct). Change if you prefer otherwise.
}

function resetQuiz(){
  initState(items.length);
  $("score").textContent = "";
  current = 0;
  renderCurrent();
  window.scrollTo({top:0, behavior:"smooth"});
}

function buildJump(){
  const sel = $("jumpSelect");
  sel.innerHTML = "";
  for(let i=0;i<items.length;i++){
    const opt = document.createElement("option");
    opt.value = String(i);
    opt.textContent = `${i+1}. ${itemStatus(i)}${previewStem(items[i].question)}`;
    sel.appendChild(opt);
  }
  sel.value = "0";
}

/* ---------------- Fetch mcq.txt (GitHub Pages, with cache-bust) ---------------- */
async function fetchText(url){
  const bust = url.includes('?') ? '&' : '?';
  const res = await fetch(url + bust + 'cb=' + Date.now(), { cache: "no-store" });
  if(!res.ok) throw new Error(`HTTP ${res.status} (${res.statusText})`);
  return await res.text();
}

async function tryFetchInOrder(urls){
  let lastErr = null;
  for(const u of urls){
    try { return { url: u, text: await fetchText(u) }; }
    catch(e){ lastErr = e; }
  }
  throw lastErr || new Error("All fetch attempts failed.");
}

async function loadMCQFrom(url){
  $("status").textContent = `Fetching ${url} ...`;
  try{
    const txt = await fetchText(url);
    items = parseMCQ(txt);
    if(!items.length){
      $("status").textContent = `Loaded ${url}, but no valid lines were found.`;
      $("quizArea").classList.add("hidden");
      document.querySelector(".loader").style.display = ""; // keep loader visible
      return;
    }
    initState(items.length);
    $("quizArea").classList.remove("hidden");
    $("status").textContent = "";                               // hide status line
    document.querySelector(".loader").style.display = "none";    // hide loader
    buildJump();
    renderCurrent();
  }catch(e){
    $("quizArea").classList.add("hidden");
    document.querySelector(".loader").style.display = ""; // show loader if failed
    $("status").textContent = `Failed to fetch/parse ${url}: ` + (e && e.message ? e.message : e);
  }
}

/* ---------------- Wire up UI ---------------- */
$("btnPrev").addEventListener("click", goPrev);
$("btnNext").addEventListener("click", goNext);
$("jumpSelect").addEventListener("change", e=>{
  const idx = parseInt(e.target.value,10);
  if(!isNaN(idx) && idx>=0 && idx<items.length){
    current = idx;
    renderCurrent();
  }
});
$("btnFirstUnanswered").addEventListener("click", ()=>{
  for(let i=0;i<items.length;i++){
    const it = items[i];
    if(it.type==='mcq' || it.type==='fitb'){
      if(userAnswers[i]==null){ current=i; renderCurrent(); return; }
    }else{
      const ua = userAnswers[i]||[];
      const rv = revealed[i]||[];
      const idx = ua.findIndex(v=>v==null || v==="");
      if(idx!==-1){ current=i; renderCurrent(); return; }
      if(rv.some(v=>!v)){ current=i; renderCurrent(); return; }
    }
  }
  current = 0; renderCurrent();
});

$("btnSubmit").addEventListener("click", submitQuiz);
$("btnReset").addEventListener("click", resetQuiz);

$("btnLoad").addEventListener("click", ()=>{
  const url = $("mcqUrl").value.trim() || "mcq.txt";
  currentMCQUrl = url;
  loadMCQFrom(url);
});
$("btnReload").addEventListener("click", ()=>{
  loadMCQFrom(currentMCQUrl);
});

/* ---------------- Auto-init (uses ?file= if provided, else smart fallbacks) ---------------- */
(function initFromQuery(){
  const params = new URLSearchParams(location.search);
  const asked = (params.get("file") || "").trim();

  const dir = location.pathname.replace(/[^/]*$/, '');
  const candidates = asked ? [asked] : [
    dir + 'mcq.txt',
    dir + 'MCQ.txt',  // legacy
    '/mcq.txt',
    '/MCQ.txt'
  ];

  $("mcqUrl").value = asked || 'mcq.txt';

  tryFetchInOrder(candidates).then(({url, text})=>{
    currentMCQUrl = url;
    items = parseMCQ(text);
    if(!items.length){
      $("status").textContent = `Loaded ${url}, but no valid lines were found.`;
      $("quizArea").classList.add("hidden");
      document.querySelector(".loader").style.display = ""; // keep loader visible
      return;
    }
    $("quizArea").classList.remove("hidden");
    $("status").textContent = "";                               // hide status line
    document.querySelector(".loader").style.display = "none";    // hide loader
    initState(items.length);
    buildJump(); renderCurrent();
  }).catch(err=>{
    $("quizArea").classList.add("hidden");
    document.querySelector(".loader").style.display = ""; // show loader if failed
    $("status").textContent = `Failed to fetch mcq.txt (tried: ${candidates.join(' , ')}). ` +
      (err && err.message ? err.message : err);
  });
})();
</script>

</body>
</html>
